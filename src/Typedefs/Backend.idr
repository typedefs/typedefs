module Typedefs.Backend

import Data.Vect
import Data.NEList

import Typedefs.Names
import Typedefs.Typedefs
import Typedefs.Backend.Utils

import Text.PrettyPrint.WL

%default total
%access public export

--TODO remove, added to TParsec
--Traversable NEList where
--  traverse f (MkNEList x xs) = [| MkNEList (f x) (traverse f xs) |]

||| Proof that a type constuctor indexed on Nat is indexed on Z or if its unbounded
|||
||| `ZeroOrUnbounded p True` means `p` is unbounded
||| `ZeroOrUnbounded p False` means `p` is indexed with `Z`
data ZeroOrUnbounded : (Nat -> Type) -> Bool -> Type where
  Unbounded : p n -> ZeroOrUnbounded p True
  Zero : p Z -> ZeroOrUnbounded p False

||| Checks if the bound assumed on an indexed type is the correct one
fromSigma : {p : Nat -> Type} -> (bounded : Bool) -> (n ** p n)
         -> Either CompilerError (ZeroOrUnbounded p bounded)
fromSigma True  (n  **pn) = Right $ Unbounded $ pn
fromSigma False (Z  **pz) = Right $ Zero $ pz
fromSigma False (S _** _) = Left $ UnknownError "Inconsistent bound"

||| Interface for interpreting type definitions as ASTs.
||| @def      the type representing definitions.
||| @type     the type representing types.
||| @freeVars flag controlling if type definition can have free variables.
interface ASTGen def type (freeVars : Bool) | def where
  ||| Given a list of `TNamed`, generate their corresponding type signatures.
  msgType          : ZeroOrUnbounded TNamedR freeVars          -> Either CompilerError type

  ||| Generate definitions for a list of `TNamed`.
  generateTyDefs   : List Name -> NEList (ZeroOrUnbounded TNamedR freeVars) -> Either CompilerError (List def)

  ||| Generate serialisation and deserialisation term definitions for a
  ||| a `TNamed` and all its helper definitions.
  generateTermDefs : NEList (ZeroOrUnbounded TNamedR freeVars) -> Either CompilerError (List def)

||| Interface for code generators that can generate code for type definitions and
||| type signatures independently of each other, for example Haskell and ReasonML.
||| @def  the type representing definitions.
||| @type the type representing types.
interface CodegenIndep def type | def where
  ||| Generate source code for a type signature.
  typeSource : type -> Doc

  ||| Generate source code for a type definition.
  defSource  : def -> Doc

  ||| A common preamble that code generated by `typeSource` and
  ||| `defSource` may use.
  preamble : Doc

||| Use the given backend to generate code for a list of type definitions.
generateDefs : (def : Type) -> (ASTGen def type fv, CodegenIndep def type) => TopLevelDef -> Either CompilerError Doc
generateDefs {fv} def (MkTopLevelDef sp tns) = (traverse (fromSigma fv) tns) >>= generateDefinitions
  where
    generateDefinitions : NEList (ZeroOrUnbounded TNamedR fv) -> Either CompilerError Doc
    generateDefinitions nel = do defs <- generateTyDefs {def} sp nel
                                 terms <- generateTermDefs {def} nel
                                 pure $ vsep2 $ (preamble {def}) :: (defSource <$> defs ++ terms)

||| Use the given backend to generate code for a list of type signatures.
generateType' : (def : Type) -> (ASTGen def type fv, CodegenIndep def type) => NEList (n ** TNamedR n) -> Either CompilerError Doc
generateType' {fv} def tns =
  typeSource {def} <$> (concatMap (msgType {def})) !(traverse (fromSigma fv) tns)

||| Here for compatiblity purposes with tests
generateType : (def : Type) -> (ASTGen def type fv, CodegenIndep def type) => NEList (n ** TNamedR n) -> Maybe Doc
generateType {fv} def tns = eitherToMaybe $ generateType' def tns

||| Interface for code generators that need to generate code for type definitions and
||| type signatures at the same time, for example the JSON schema backend.
||| @def  the type representing type definitions.
||| @type the type representing type signatures.
interface CodegenInterdep def type where
  ||| Generate source code for a type signature and a list of helper definitions.
  sourceCode   : NEList type -> List def -> Doc

||| Use the given backend to generate code for a list of type definitions.
generate' : (def : Type) -> (ASTGen def type fv, CodegenInterdep def type) => NEList (n ** TNamedR n) -> Either CompilerError Doc
generate' {fv} def tns = (traverse (fromSigma fv) tns) >>= generateDefinitions
  where
    generateDefinitions : NEList (ZeroOrUnbounded TNamedR fv) -> Either CompilerError Doc
    generateDefinitions nel = do types <- traverse (msgType {def}) nel
                                 defs <- generateTyDefs {def} [] nel
                                 terms <- generateTermDefs {def} nel
                                 pure $ sourceCode types (defs ++ terms)

||| Here for compatibilty purpopses with tests
generate : (def : Type) -> (ASTGen def type fv, CodegenInterdep def type) => NEList (n ** TNamedR n) -> Maybe Doc
generate {fv} def tns = eitherToMaybe $ generate' def tns

{-
record SpecialiseEntry where
  constructor MkSpecialiseEntry
  tdef : TDef 0
  ||| name of type used for specialisation
  targetType : String
  ||| name of function of target type generateType tdef -> targetType
  encodeFun : String
  ||| name of function of target type targetType -> generateType tdef
  decodeFun : String

||| Generate type definitions according to an *ordered* set of specialisation entries.
generateDefsSpecialised : Backend lang => Vect (S m') SpecialiseEntry -> (n : Nat) -> TDef n -> List lang
generateDefsSpecialised {lang} {m' = m'} table n td = generateTyDefs e td'
   where m : Nat
         m = S m'
         e : Env (n + m)
         e = freshEnv {lang} n ++ map (\ s => Right $ MkDecl (targetType s) []) table
         traverseTD : (n : Nat) -> (Fin m, SpecialiseEntry) -> TDef (n + m) -> TDef (n + m)
         traverseTD n (i, se) t = if t == weakenTDef (tdef se) _ (lteAddRight 0)
                                    then replace prf (TVar (fromNat (n + toNat i)))
                                    else go t
             where prf : m + n = n + m
                   prf = plusCommutative m n
                   go : TDef (n + m) -> TDef (n + m)
                   go T0 = T0
                   go T1 = T1
                   go (TSum xs)  = TSum (assert_total $ map (traverseTD n (i, se)) xs)
                   go (TProd xs) = TProd (assert_total $ map (traverseTD n (i, se)) xs)
                   go (TMu xs)   = TMu (assert_total $ map (\(c, t) => (c,traverseTD (S n) (i, se) t)) xs)
                   --go (TName name t) = TName name (traverseTD n (i, se) t)
                   go (TApp f xs) = ?goTApp
                   go x = x -- only TVar i case left
         td' : TDef (n + m)
         td' = foldl (flip (traverseTD n)) (weakenTDef td (n + m) (lteAddRight n)) (zip range table)
-}
